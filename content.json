{"meta":{"title":"朱梦迪的博客","subtitle":"一梦不醒","description":"记录一些自己的感悟和姿势","author":"朱梦迪","url":"http://yoursit.com"},"pages":[{"title":"关于我","date":"2018-01-09T06:17:51.000Z","updated":"2018-01-09T06:17:51.000Z","comments":true,"path":"about/index.html","permalink":"http://yoursit.com/about/index.html","excerpt":"","text":"以梦为马，欢迎指教 🌎Location:Shanghai, China 👻Github: @mengdi.zhu 📩Email: @zhumengdi"},{"title":"","date":"2018-01-09T04:16:36.000Z","updated":"2018-01-09T04:16:36.000Z","comments":true,"path":"tags/index.html","permalink":"http://yoursit.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"记一个用短路逻辑运算替换if单语句的骚操作（适合于弱类型语言）","slug":"记一个用短路逻辑运算替换if单语句的骚操作（适合于弱类型语言","date":"2018-02-03T10:58:04.000Z","updated":"2018-02-03T12:11:33.000Z","comments":true,"path":"2018/02/03/记一个用短路逻辑运算替换if单语句的骚操作（适合于弱类型语言/","link":"","permalink":"http://yoursit.com/2018/02/03/记一个用短路逻辑运算替换if单语句的骚操作（适合于弱类型语言/","excerpt":"","text":"ps: 短路逻辑和普通逻辑运算之间的差别不多作介绍，请自行百度🙂 短路逻辑运算： &amp;&amp; 是短路逻辑与 短路逻辑与表达式：A &amp;&amp; B如果A结果代表true， 表达式结果为B结果如果A结果代表false，表达式结果为A结果，不再执行B判断 || 是短路逻辑或 短路逻辑或表达式：A || B如果A结果代表false，表达式结果为B结果如果A结果代表true，表达式结果为A结果，不在执行B判断 来看下面这样一段代码:123456789101112131415161718 // javascript function getMember(callback) &#123; $.ajax(&#123; type:&quot;GET&quot;, url:&quot;/meiya/getMember&quot;, data:&#123; phone:phone, giftType:&apos;A&apos; &#125;, dataType:&quot;json&quot;, success:function(res)&#123; typeof callback == &apos;function&apos; &amp;&amp; callback(res); &#125;, error:function()&#123; _this.popShow($(&quot;.pop-content&quot;)); &#125; &#125;);&#125; 其中有一条语句是1typeof callback == &apos;function&apos; &amp;&amp; callback(res); 如果callback == &#39;function&#39;代表true，则会继续执行callback(res)；如果callback == &#39;function&#39;代表false，则不会继续执行，直接返回。 因此，这条语句相当于等价下面的if语句块12345// javascriptif (typeof callback == &apos;function&apos;) &#123; callback(res);&#125; 弱类型语言中，在某些情况下，我们就可以用短路逻辑运算表达式来代替if语句块了，让自己代码更加有趣，也可以算是一种语法🍬。 通用地， javascript语言：12345678910A &amp;&amp; Bif (A) &#123; B&#125;A || Bif (!A) &#123; B&#125; python语言：1234567A and Bif A: BA || Bif !A: B","categories":[],"tags":[{"name":"编程语言 语法 弱语言","slug":"编程语言-语法-弱语言","permalink":"http://yoursit.com/tags/编程语言-语法-弱语言/"}]},{"title":"jdk7异常捕获的新玩法","slug":"jdk7异常捕获的新玩法","date":"2018-01-17T04:14:50.000Z","updated":"2018-01-19T06:53:28.000Z","comments":true,"path":"2018/01/17/jdk7异常捕获的新玩法/","link":"","permalink":"http://yoursit.com/2018/01/17/jdk7异常捕获的新玩法/","excerpt":"","text":"1.catch多种异常抛出一种异常 在JDK1.7之前catch多个异常是这样的：1234567891011try&#123; //逻辑代码 &#125;catch (IOException ex) &#123; logger.log(ex); throw new SpecialException(); catch (SQLException ex) &#123; logger.log(ex); throw new SpecialException(); &#125; JDK1.7及以后可以这样：12345678try&#123; //逻辑代码 &#125;catch (IOException | SQLException ex) &#123; logger.log(ex); throw new SpecialException(); &#125; 2.在JDK1.7以前的版本，在方法声明中声明抛出的异常如果在方法体内没有抛出时不被允许的,如下 123456789101112131415161718192021222324252627static class FirstException extends Exception &#123; &#125; static class SecondException extends Exception &#123; &#125; public void rethrowException(String exceptionName) throws FirstException, SecondException,Exception &#123; try &#123; if (exceptionName.equals(&quot;First&quot;)) &#123; //如果异常名称为&quot;First&quot;，则抛出异常一 throw new FirstException(); &#125; else &#123; //否则的话，则抛出异常二 throw new SecondException(); &#125; &#125; catch (Exception e) &#123; throw e; &#125; &#125; JDK1.7及以后版本： 12345678910111213141516static class FirstException extends Exception &#123; &#125; static class SecondException extends Exception &#123; &#125; public void rethrowException(String exceptionName) throws FirstException, SecondException,Exception &#123; try &#123; // 逻辑代码 &#125;catch (Exception e) &#123; throw e; &#125; &#125;","categories":[],"tags":[{"name":"java语言","slug":"java语言","permalink":"http://yoursit.com/tags/java语言/"}]},{"title":"如何在SpringMVC任何地方获取http请求流的request和response","slug":"如何在springMVC任何地方获取http请求流的request和response","date":"2018-01-15T06:10:49.000Z","updated":"2018-01-15T07:35:48.000Z","comments":true,"path":"2018/01/15/如何在springMVC任何地方获取http请求流的request和response/","link":"","permalink":"http://yoursit.com/2018/01/15/如何在springMVC任何地方获取http请求流的request和response/","excerpt":"","text":"我们在使用SpringMVC作为web框架时，我们会遇到一些情况会需要操作http连接的request和response对象。当然，SpringMVC提供了很好的一种方式：依赖注入，将对象注入到方法中来供我们直接操作。 但是，在某些地方，我们仍然需要自己去获得request和response对象，比如spring的Advice切面中。这就带来了问题，我们怎么样能在springMVC的任意一个地方获得自身http线程的request和response对象。好在SpringMVC提供了这样的操作。 1234567 final ServletRequestAttributes requestAttributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();// 获取request对象 final HttpServletRequest request = requestAttributes.getRequest();// 获取response对象 final HttpServletResponse response = requestAttributes.getResponse(); 是不是很方便很舒服😋 没想到获取request和response能这么容易 依靠这种操作，自己写了一个http请求访问的日志记录AOP Adivice。有需要的小伙伴可以在这基础上修改直接引入到自己的项目中。附上：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384package com.alifu.aop;import com.alibaba.druid.util.StringUtils;import com.alibaba.fastjson.JSONObject;import org.apache.tools.ant.util.FileUtils;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.Around;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Pointcut;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.http.HttpMethod;import org.springframework.stereotype.Component;import org.springframework.web.context.ContextLoader;import org.springframework.web.context.request.RequestContextHolder;import org.springframework.web.context.request.ServletRequestAttributes;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.InputStreamReader;import java.util.Optional;/** * @author zhumengdi E-mail:montyzhu7@163.com * @version created：2018/1/10 下午7:20 */@Aspect@Componentpublic class ControllerLogAspect &#123; Logger logger = LoggerFactory.getLogger(getClass()); @Pointcut(&quot;within(@org.springframework.stereotype.Controller *)&quot;) private static void withinController() &#123; &#125; @Pointcut(&quot;execution(@org.springframework.web.bind.annotation.RequestMapping * *(..))&quot;) private static void executionRequestMapping() &#123; &#125; @Pointcut(&quot;(&quot; + &quot;withinController()&quot; + &quot;&amp;&amp; executionRequestMapping())&quot;) private static void logHttp() &#123; &#125; @Around(&quot;logHttp()&quot;) public Object aroundCall(final ProceedingJoinPoint joinPoint) throws Throwable &#123; final ServletRequestAttributes requestAttributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes(); final HttpServletRequest request = requestAttributes.getRequest(); final String requestURI = request.getRequestURI(); final String queryString = request.getQueryString(); Optional&lt;String&gt; postData = Optional.&lt;String&gt;empty(); if (StringUtils.equals(HttpMethod.POST.name(), request.getMethod())) &#123; final String s = FileUtils.readFully(new InputStreamReader(request.getInputStream(), &quot;utf-8&quot;)); postData = Optional.of(s); &#125; logger.info(request.getMethod() + &quot;-&quot; + requestURI + &quot;?&quot; + queryString + postData.map(e -&gt; &quot; postData: &quot; + JSONObject.toJSONString(e)).orElse(&quot;&quot;)); long start = System.currentTimeMillis(); final Object proceed = joinPoint.proceed(); long end = System.currentTimeMillis(); final HttpServletResponse response = requestAttributes.getResponse(); logger.info(request.getMethod() + &quot;-&quot; + requestURI + &quot;?&quot; + queryString + postData.map(e -&gt; &quot; postData: &quot; + JSONObject.toJSONString(e)).orElse(&quot;&quot;) + &quot; ====== elapsed by [&quot; + (end - start) + &quot;]ms&quot; + &quot; status: [&quot; + response.getStatus() + &quot;]&quot;); return proceed; &#125;&#125;","categories":[],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursit.com/tags/Spring/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://yoursit.com/tags/SpringMVC/"}]},{"title":"log4j中log4j.logger和log4j.category区别","slug":"log4j中log4j-logger和log4j-category区别","date":"2018-01-10T07:29:36.000Z","updated":"2018-01-15T07:02:24.000Z","comments":true,"path":"2018/01/10/log4j中log4j-logger和log4j-category区别/","link":"","permalink":"http://yoursit.com/2018/01/10/log4j中log4j-logger和log4j-category区别/","excerpt":"","text":"在一些log4j.properties配置文件中，你可能会发现同时存在log4j.logger和log4j.category两种配置 这是log4j版本升级情况下的历史遗留问题。 log4j.category是老版本的用法，log4j.logger是新版本的用法，前一种已经不再推荐被使用，但是为了兼容旧版本代码，log4j仍然支持这样使用。 log4j官方网站上也给出了完整的解释： public class Categoryextends java.lang.Objectimplements AppenderAttachableThis class has been deprecated and replaced by the Logger subclass. It will be kept around to preserve backward compatibility until mid 2003. Logger is a subclass of Category, i.e. it extends Category. In other words, a logger is a category. Thus, all operations that can be performed on a category can be performed on a logger. Internally, whenever log4j is asked to produce a Category object, it will instead produce a Logger object. Log4j 1.2 will never produce Category objects but only Logger instances. In order to preserve backward compatibility, methods that previously accepted category objects still continue to accept category objects. For example, the following are all legal and will work as expected. // Deprecated form: Category cat = Category.getInstance(&quot;foo.bar&quot;) // Preferred form for retrieving loggers: Logger logger = Logger.getLogger(&quot;foo.bar&quot;) The first form is deprecated and should be avoided. There is absolutely no need for new client code to use or refer to the Category class. Whenever possible, please avoid referring to it or using it. See the short manual for an introduction on this class. See the document entitled preparing for log4j 1.3 for a more detailed discussion.","categories":[],"tags":[{"name":"log4j","slug":"log4j","permalink":"http://yoursit.com/tags/log4j/"}]},{"title":"解决Spring JPA中hibernate执行sql日志不打印sql参数值的问题","slug":"解决hibernate中sql日志打印不显示参数值","date":"2018-01-10T07:15:26.000Z","updated":"2018-01-15T07:03:15.000Z","comments":true,"path":"2018/01/10/解决hibernate中sql日志打印不显示参数值/","link":"","permalink":"http://yoursit.com/2018/01/10/解决hibernate中sql日志打印不显示参数值/","excerpt":"","text":"在Spring JPA的spring配置文件中，我们在bean对象EntityManagerFactory的jpaProperties属性配置hibernate的日志参数，即可使程序执行数据库过程打印出sql语句，代码如下： 1234567891011121314151617181920&lt;!-- 配置EntityManagerFactory--&gt; &lt;bean id=&quot;entityManagerFactory&quot; class=&quot;org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;property name=&quot;jpaVendorAdapter&quot;&gt; &lt;bean class=&quot;org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter&quot;/&gt; &lt;/property&gt; &lt;property name=&quot;packagesToScan&quot; value=&quot;com.alifu&quot;/&gt; &lt;property name=&quot;jpaProperties&quot;&gt; &lt;props&gt; &lt;prop key=&quot;hibernate.ejb.naming_strategy&quot;&gt;org.hibernate.cfg.ImprovedNamingStrategy&lt;/prop&gt; &lt;prop key=&quot;hibernate.dialect&quot;&gt;org.hibernate.dialect.MySQL5InnoDBDialect&lt;/prop&gt; &lt;prop key=&quot;hibernate.show_sql&quot;&gt;false&lt;/prop&gt; &lt;prop key=&quot;hibernate.format_sql&quot;&gt;true&lt;/prop&gt; &lt;prop key=&quot;hibernate.hbm2ddl.auto&quot;&gt;update&lt;/prop&gt; &lt;prop key=&quot;hibernate.use_sql_comments&quot;&gt;true&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; 关键配置在于123&lt;prop key=&quot;hibernate.show_sql&quot;&gt;false&lt;/prop&gt; // 是否显示sql语句&lt;prop key=&quot;hibernate.format_sql&quot;&gt;true&lt;/prop&gt; // 是否格式化显示，更加易读&lt;prop key=&quot;hibernate.use_sql_comments&quot;&gt;true&lt;/prop&gt; // 是否在sql语句前加上方法注释 这样配置后，的确在程序运行中，每一次JPA操作数据库执行sql都会在日志中打印出sql语句。 但是，效果并不尽如人意，其中sql语句中的值参数却是?形式显示在日志中，如下所示1234567891011121314151617181920212223242526272829303132333435363738394041Hibernate: select alipaymemb0_.auth_appid as auth_app1_0_0_, alipaymemb0_.user_uni_id as user_uni2_0_0_, alipaymemb0_.user_uni_id_type as user_uni3_0_0_, alipaymemb0_.balance as balance4_0_0_, alipaymemb0_.birth as birth5_0_0_, alipaymemb0_.biz_card_no as biz_card6_0_0_, alipaymemb0_.card_template_id as card_tem7_0_0_, alipaymemb0_.cell as cell8_0_0_, alipaymemb0_.external_card_no as external9_0_0_, alipaymemb0_.gender as gender10_0_0_, alipaymemb0_.level as level11_0_0_, alipaymemb0_.name as name12_0_0_, alipaymemb0_.open_card_channel as open_ca13_0_0_, alipaymemb0_.open_card_channel_id as open_ca14_0_0_, alipaymemb0_.open_date as open_da15_0_0_, alipaymemb0_.point as point16_0_0_, alipaymemb0_.valid_date as valid_d17_0_0_ from alipay_member_card alipaymemb0_ where alipaymemb0_.auth_appid=? and alipaymemb0_.user_uni_id=? and alipaymemb0_.user_uni_id_type=?Hibernate: /* delete com.alifu.model.alimodel.AlipayMemberCard */ delete from alipay_member_card where auth_appid=? and user_uni_id=? and user_uni_id_type=?Hibernate: /* insert com.alifu.model.alimodel.AlipayMemberCard */ insert into alipay_member_card (balance, birth, biz_card_no, card_template_id, cell, external_card_no, gender, level, name, open_card_channel, open_card_channel_id, open_date, point, valid_date, auth_appid, user_uni_id, user_uni_id_type) values (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?) 这样的显示，显然不符合我们的预期，也对日后的问题排查带来了难度。我们必须要让具体的参数值也显示在sql中。 为了实现这个效果。 引入第三方jar包 123456&lt;!--打印jdbc日志--&gt;&lt;dependency&gt; &lt;groupId&gt;com.googlecode.log4jdbc&lt;/groupId&gt; &lt;artifactId&gt;log4jdbc&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; 配置日志级别 1234567log4j.logger.jdbc.sqltiming=infolog4j.logger.jdbc.audit=xxxlog4j.logger.jdbc.sqlonly=xxxlog4j.logger.jdbc.resultset=xxx# 推荐,log4j.logger.jdbc=warn mysql配置 （关键步骤） 1234567#改变jdbc连接URL 和 jdbc的驱动类，原理是由log4jdbc代理java基础库中的JDBC，实现日志打印jdbc.url=jdbc:log4jdbc:mysql://192.168.2.119:3306/rdms-pollution?useUnicode=true&amp;characterEncoding=utf-8jdbc.username=rootjdbc.password=rootjdbc.driverClassName =net.sf.log4jdbc.DriverSpy entityManagerFactory中jpaProperties可以去掉hibernate的日志参数了（可选步骤） 123&lt;prop key=&quot;hibernate.show_sql&quot;&gt;false&lt;/prop&gt; // 是否显示sql语句&lt;prop key=&quot;hibernate.format_sql&quot;&gt;true&lt;/prop&gt; // 是否格式化显示，更加易读&lt;prop key=&quot;hibernate.use_sql_comments&quot;&gt;true&lt;/prop&gt; // 是否在sql语句前加上方法注释","categories":[],"tags":[{"name":"JPA","slug":"JPA","permalink":"http://yoursit.com/tags/JPA/"}]},{"title":"django在mac上初体验","slug":"django在mac上初体验","date":"2018-01-09T08:59:40.000Z","updated":"2018-01-09T10:04:39.000Z","comments":true,"path":"2018/01/09/django在mac上初体验/","link":"","permalink":"http://yoursit.com/2018/01/09/django在mac上初体验/","excerpt":"","text":"Django 安装在安装 Django 前，系统需要已经安装了Python的开发环境。python的安装不赘述，我们使用的版本是python3 下载安装包从https://www.djangoproject.com/download下载最新的稳定版本：DJango-1.x.y.tar.gz，在页面右侧列表下载，如下图： 你也可以从 Github 上下载最新版，地址：https://github.com/django/djangogit clone https://github.com/django/django.git 安装进入解压后的目录 12cd Django-1.x.ysudo python setup.py install 安装成功后会输出以下信息：12Processing dependencies for Django==1.x.yFinished processing dependencies for Django==1.x.y 再进入我们的站点目录，创建 Django 项目：django-admin.py startproject testdj启动服务：12345cd testdj # 切换到我们创建的项目$ python manage.py runserver……Starting development server at http://127.0.0.1:8000/Quit the server with CONTROL-C. 访问地址为http://127.0.0.1:8000/效果如图所示","categories":[],"tags":[{"name":"django","slug":"django","permalink":"http://yoursit.com/tags/django/"}]},{"title":"使用DigitalOcean自建VPS翻墙","slug":"使用DigitalOcean自建VPS翻墙","date":"2018-01-09T06:32:52.000Z","updated":"2018-01-09T07:58:26.000Z","comments":true,"path":"2018/01/09/使用DigitalOcean自建VPS翻墙/","link":"","permalink":"http://yoursit.com/2018/01/09/使用DigitalOcean自建VPS翻墙/","excerpt":"","text":"今年以来国内加大了对VPN的管控，导致大规模vpn服务提供商关闭服务。如今仅剩的一些vpn软件不是服务不稳定时常掉线就是价格昂贵。所以，现今相比于以前的购买vpn服务，不如自己搭建vps更为明智。不但相对价格低廉没有中间商赚差价😀，而且独立使用服务更加稳定。 Digital Ocean云主机digital ocean 是一家国外的vps提供商。首先打开官网注册账号，激活邮箱。接着，你就可以在上面创立属于自己的虚拟主机了，不过在这之前你需要绑定信用卡或者直接在你账户里冲入5美元才能正式开始使用。这两种方式没有本质上区别，我使用的是第一种方式，其优点在于采用的是后付费的方式，你能够先使用服务再付费，每个月底会结算一次费用并生成到你的信用卡账单中，你须要每个月按时还款信用卡即可，当然它的入账金额是美元，还款时按当时的汇率结算。 然后就可以创建你的云主机了，在DigitalOcean中的概念叫做Droplets。像阿里云ECS一样提供了多种规格选择对于个人来说，选择$5/mon 来支撑shadowsocks[^1]的服务足矣。购买成功之后，就能在个人资源下找到这台主机，并且账号的注册邮箱会收到一封包含root账号密码的邮件最后，就是登入到这台云主机，这里有一个很坑的地方。按道理说有了ip和密码应该就能直接ssh这台主机了，但是新创建云主机的sshd配置默认没有打开ssh的密码访问方式（好像只有digital ocean这么干），只能在web界面使用console access进入控制台。进入web控制台，修改/etc/ssh/sshd_config文件，将PasswordAuthentication no改为PasswordAuthentication yes，即可从ssh密码访问这台主机。 Shadowsocks在主机上安装shadowsocks首先ssh远程登入到云主机，比如主机ip是104.236.77.17ssh root@104.236.77.17 在 Debian / Ubuntu 下 安装shadowsocksapt-get install python-pip pip install shadowsocks我在实际安装下发现很多依赖缺失，所以需要先执行一下：apt-get update。另外也有一些同学会选择CentOS的服务器，附上在CentOS下安装shadowsocks的方法：12yum install python-setuptools &amp;&amp; easy_install pippip install shadowsocks 启动shadowsocks服务安装好shadowsocks以后，启动shadowsocks服务可以通过以下指令： 12345ssserver -p 8836 -k `password` -m rc4-md5#或者可以通过以下指令在后台启动shadowsocks的服务：ssserver -p 8836 -k `password` -m rc4-md5 -d startssserver -p 8836 -k `password` -m rc4-md5 -d stop 但上面的方法很不方便，我还是推荐使用配置文件的方法。首先创建一个文件：/etc/shadowsocks.json，示例如下：12345678910&#123; &quot;server&quot;:&quot;你的服务器ip地址&quot;, &quot;server_port&quot;:8388, &quot;local_address&quot;: &quot;127.0.0.1&quot;, &quot;local_port&quot;:1080, &quot;password&quot;:&quot;你设置的密码&quot;, &quot;timeout&quot;:300, &quot;method&quot;:&quot;aes-256-cfb&quot;, &quot;fast_open&quot;: false&#125; 接下来你就可以使用下面这个指令启动服务12345ssserver -c /etc/shadowsocks.json#或者在后台运行ssserver -c /etc/shadowsocks.json -d startssserver -c /etc/shadowsocks.json -d stop 使用shadowsocks客户端shadowsocks的客户端支持各大主流平台，而且客户端的配置一般都很简单，只需要配置一下服务器的ip地址和之前设置好的连接密码即可。 下载地址:clients","categories":[],"tags":[{"name":"vpn","slug":"vpn","permalink":"http://yoursit.com/tags/vpn/"},{"name":"ssh","slug":"ssh","permalink":"http://yoursit.com/tags/ssh/"}]}]}